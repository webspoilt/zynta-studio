//! Code Provenance Blockchain Ledger
//!
//! A local, append-only cryptographic chain that hashes and tags
//! every code snippet's origin as either `ZYNTA_GEN` (AI-generated)
//! or `USER_AUTH` (human-authored), providing indisputable proof
//! of intellectual property and original authorship.

use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};
use std::sync::Mutex;
use lazy_static::lazy_static;
use chrono::{DateTime, Utc};

// ─────────────────────────────────────────────────────────
//  Data Types
// ─────────────────────────────────────────────────────────

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum CodeOrigin {
    /// Code written entirely by the human user
    UserAuth,
    /// Code generated by the Zynta AI engine
    ZyntaGen,
    /// Code imported from an external source (web scraper, copy-paste)
    ExternalImport,
    /// Mixed origin (user modified AI-generated code)
    HybridEdit,
}

impl std::fmt::Display for CodeOrigin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CodeOrigin::UserAuth => write!(f, "USER-AUTH"),
            CodeOrigin::ZyntaGen => write!(f, "ZYNTA-GEN"),
            CodeOrigin::ExternalImport => write!(f, "EXTERNAL"),
            CodeOrigin::HybridEdit => write!(f, "HYBRID"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProvenanceBlock {
    pub index: u64,
    pub hash: String,
    pub prev_hash: String,
    pub timestamp: String,
    pub file_path: String,
    pub line_range: (usize, usize),
    pub origin: CodeOrigin,
    pub snippet_sha256: String,
    pub author: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChainStatus {
    pub total_blocks: u64,
    pub is_valid: bool,
    pub user_auth_count: u64,
    pub zynta_gen_count: u64,
    pub hybrid_count: u64,
    pub last_block_hash: String,
}

// ─────────────────────────────────────────────────────────
//  Ledger Implementation
// ─────────────────────────────────────────────────────────

lazy_static! {
    static ref LEDGER: Mutex<Vec<ProvenanceBlock>> = Mutex::new(Vec::new());
}

/// Compute SHA-256 hash of a string
fn sha256(input: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    hex::encode(hasher.finalize())
}

/// Compute the block hash from its contents
fn compute_block_hash(block: &ProvenanceBlock) -> String {
    let payload = format!(
        "{}:{}:{}:{}:{}:{:?}:{}",
        block.index,
        block.prev_hash,
        block.timestamp,
        block.file_path,
        block.snippet_sha256,
        block.origin,
        block.author,
    );
    sha256(&payload)
}

/// Record a new code edit into the provenance ledger
pub fn record_edit(
    file_path: &str,
    line_range: (usize, usize),
    origin: CodeOrigin,
    snippet: &str,
    author: &str,
) -> ProvenanceBlock {
    let mut ledger = LEDGER.lock().unwrap();

    let index = ledger.len() as u64;
    let prev_hash = ledger.last().map(|b| b.hash.clone()).unwrap_or_else(|| "GENESIS".to_string());
    let snippet_sha256 = sha256(snippet);
    let timestamp = Utc::now().to_rfc3339();

    let mut block = ProvenanceBlock {
        index,
        hash: String::new(), // computed below
        prev_hash,
        timestamp,
        file_path: file_path.to_string(),
        line_range,
        origin,
        snippet_sha256,
        author: author.to_string(),
    };

    block.hash = compute_block_hash(&block);
    ledger.push(block.clone());

    block
}

/// Query the provenance history for a specific file
pub fn query_history(file_path: &str) -> Vec<ProvenanceBlock> {
    let ledger = LEDGER.lock().unwrap();
    ledger
        .iter()
        .filter(|b| b.file_path == file_path)
        .cloned()
        .collect()
}

/// Verify the integrity of the entire chain
pub fn verify_chain() -> ChainStatus {
    let ledger = LEDGER.lock().unwrap();

    let mut is_valid = true;
    let mut user_auth_count: u64 = 0;
    let mut zynta_gen_count: u64 = 0;
    let mut hybrid_count: u64 = 0;

    for (i, block) in ledger.iter().enumerate() {
        // Verify hash
        let expected_hash = compute_block_hash(block);
        if block.hash != expected_hash {
            is_valid = false;
            break;
        }

        // Verify chain linkage
        if i > 0 {
            if block.prev_hash != ledger[i - 1].hash {
                is_valid = false;
                break;
            }
        } else if block.prev_hash != "GENESIS" {
            is_valid = false;
            break;
        }

        // Count origins
        match block.origin {
            CodeOrigin::UserAuth => user_auth_count += 1,
            CodeOrigin::ZyntaGen => zynta_gen_count += 1,
            CodeOrigin::HybridEdit => hybrid_count += 1,
            _ => {}
        }
    }

    ChainStatus {
        total_blocks: ledger.len() as u64,
        is_valid,
        user_auth_count,
        zynta_gen_count,
        hybrid_count,
        last_block_hash: ledger.last().map(|b| b.hash.clone()).unwrap_or_else(|| "GENESIS".into()),
    }
}
